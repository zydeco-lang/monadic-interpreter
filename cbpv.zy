codata Monad (M: VType -> CType) where
  | .return(): forall (A: VType) . A -> M A
  | .bind(): forall (A: VType) (A': VType) . U (M A) -> U (A -> M A') -> M A'
  | .fail(): forall (A: VType) . Exception -> M A
  // | .print(): String -> M Unit
end

codata Algebra (M: VType -> CType) (N: VType -> CType) where
  | .bindA(): forall (A: VType) . U (M A) -> U (A -> N A) -> N A
end

data Exception where
  | TypeError()
  | FreeVariable()
end

codata MExn (A: VType) where
  | .run(): forall (R: CType) . U (A -> R) -> U (Exception -> R) -> R
end

def fn mexn : Monad MExn =
  comatch
  | .return() -> fn A a ->
    comatch
    | .run() -> fn R ka _ -> ! ka a
    end
  | .bind() -> fn A A' m f ->
    comatch
    | .run() -> fn R ka ke ->
      ! m .run() @(R) { fn a -> ! f a .run() @(R) ka ke } { fn e -> ! ke e }
    end
  | .fail() -> fn A e ->
    comatch
    | .run() -> fn R _ ke -> ! ke e
    end
  // | .print() -> fn s ->
  //   comatch
  //   | .run() -> fn R ka _ ->
  //     ! write_line s { ! ka Unit() }
  //   end
  end
end

data EnvT where
  | Empty()
  | Extend(String, Value, EnvT)
end

codata EnvO where
  | .lookup(): String -> Ret (Option Value)
  | .extend(): String -> Value -> EnvO
end

def rec fn envo (env: EnvT) : EnvO =
  comatch
  | .lookup() -> fn x ->
    match env
    | Empty() -> ret None()
    | Extend(x', v, env') ->
      do is-eq? <- ! str_eq x x';
      match is-eq?
      | True() -> ret Some(v)
      | False() -> ! envo env' .lookup() x
      end
    end
  | .extend() -> fn x v ->
    ! envo Extend(x, v, env)
  end
end

data Value where
  | Bool(Bool)
  | Thunk(U (Compu Value))
end

codata Compu (A: VType) where
  | .app(): A -> Compu A
  | .bind(): MExn A
end

def fn abort (A: VType) (e: Exception) : Compu A =
  rec unwind -> comatch
  | .app() -> fn _ -> ! unwind
  | .bind() -> ! mexn .fail() @(A) e
  end
end

def rec fn malg : Algebra MExn Compu =
  comatch
  | .bindA() -> fn A m f ->
    ! m .run() @(Compu A) f { ! abort @(A) }
  end
end

data SValue where
  | Var(String)
  | Bool(Bool)
  | Thunk(SCompu)
end

data SCompu where
  | Lam(String, SCompu)
  | App(SCompu, SValue)
  | Ret(SValue)
  | Bind(SCompu, String, SCompu)
  | Force(SValue)
  | If(SValue, SCompu, SCompu)
end

codata Interp where
  | .value(): SValue -> MExn Value
  | .compu(): SCompu -> Compu Value
end

def rec fn interp (env: U EnvO) : Interp =
  comatch
  | .value() -> fn sv ->
    match sv
    | Var(x) ->
      do x? <- ! env .lookup() x;
      match x?
      | None() -> ! mexn .fail() @(Value) FreeVariable()
      | Some(v) ->
        ! mexn .return() @(Value) v
      end
    | Bool(b) ->
      ! mexn .return() @(Value) Bool(b)
    | Thunk(c) ->
      ! mexn .return() @(Value) Thunk({ ! interp env .compu() c })
    end
  | .compu() -> fn sc ->
    match sc
    | Lam(x, sc) ->
      comatch
      | .app() -> fn v ->
        ! interp { ! env .extend() x v } .compu() sc
      | .bind() -> ! mexn .fail() @(Value) TypeError()
      end
    | App(sc, sv) ->
      let mv = { ! interp env .value() sv } in
      ! malg .bindA() @(Value) mv { fn v -> ! interp env .compu() sc .app() v }
    | Ret(sv) ->
      let rec fn unwind (m: U (MExn Value)) : Compu Value =
        comatch
        | .app() -> fn _ -> ! unwind { ! mexn .fail() @(Value) TypeError() }
        | .bind() -> ! m
        end
      in
      ! unwind { ! interp env .value() sv }
    | Bind(sc1, x, sc2) ->
      let mv = { ! interp env .compu() sc1 .bind() } in
      ! malg .bindA() @(Value) mv { fn v ->
        ! interp { ! env .extend() x v } .compu() sc2
      }
    | Force(sv) ->
      let mv = { ! interp env .value() sv } in
      ! malg .bindA() @(Value) mv { fn v ->
        match v
        | Bool(_) -> ! abort @(Value) TypeError()
        | Thunk(c) -> ! c
        end
      }
    | If(sv, c1, c2) ->
      let mv = { ! interp env .value() sv } in
      ! malg .bindA() @(Value) mv { fn v ->
        match v
        | Bool(b) ->
          match b
          | True() -> ! interp env .compu() c1
          | False() -> ! interp env .compu() c2
          end
        | Thunk(_) -> ! abort @(Value) TypeError()
        end
      }
    end
  end
end

main
  let env : U EnvO = { ! envo Empty() } in
  let fn report (e: Exception) : OS =
    match e
    | TypeError() -> ! panic "type error"
    | FreeVariable() -> ! panic "free variable"
    end
  in
  let fn value-eq (v1: Value) (v2: Value) (k: U OS) : OS =
    let bool-value-panic = { ! panic "wrong bool value" } in
    let thunk-panic = { ! panic "thunks are not comparable" } in
    match v1
    | Bool(b1) ->
      match v2
      | Bool(b2) ->
        do eq? <- ! bool_eq b1 b2;
        match eq?
        | True() -> ! write_line "\\^o^/" k
        | False() -> ! bool-value-panic
        end
      | Thunk(_) -> ! thunk-panic
      end
    | Thunk(_) -> ! thunk-panic
    end
  in
  let fn demo (term: SCompu) (ans: Value) (k: U OS): OS =
    ! interp env .compu() term .bind() .run() @(OS) {
      fn v -> ! value-eq v ans k
    } report
  in
  let term1: SCompu = If(Bool(True()), Ret(Bool(True())), Ret(Bool(False()))) in
  let ans1: Value = Bool(True()) in
  let term2: SCompu = App(Lam("x", Ret(Var("x"))), Bool(True())) in
  let ans2: Value = Bool(True()) in
  ! demo term1 ans1 {
  ! demo term2 ans2 {
  ! exit 0 }}
end
