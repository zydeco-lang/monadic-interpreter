// A monad structure
codata Monad (M: VType -> CType) where
  | .return(): forall (A: VType) . A -> M A
  | .bind(): forall (A: VType) (A': VType) . U (M A) -> U (A -> M A') -> M A'
end

// A monad structure that supports fail
codata MonadErr (M: VType -> CType) where
  | .fail(): forall (A: VType) . Exception -> M A
end

// A monad structure that supports print
codata MonadPrint (M: VType -> CType) where
  | .print(): String -> M Unit
end

codata MonadAlt (M: VType -> CType) where
  | .alt(): forall (A: VType) . U (M A) -> U (M A) -> M A
end

codata MonadReduce (M: VType -> CType) where
  | .reduce(): forall (A: VType) . List (U (M A)) -> U (M A) -> M A
end

codata MonadTrans (T: (VType -> CType) -> VType -> CType) where
  | .lift(): forall (M: VType -> CType) (A: VType) . U (Monad M) -> U (M A) -> T M A
end

// An algebra structure that supports fail
codata Algebra (M: VType -> CType) (B: CType) where
  | .bindA(): forall (A: VType) . U (M A) -> U (A -> B) -> B
end

// An algebra structure that supports fail
codata AlgebraErr (M: VType -> CType) (B: CType) where
  | .failA(): Exception -> B
end

data Exception where
  | ParseError(Int, String)
  | FreeVariable()
  | TypeError()
end

// Continuation-based error monad
codata MExnOS (A: VType) where
  | .run(): U (A -> OS) -> U (Exception -> OS) -> OS
end

def fn mexn : Monad MExnOS =
  comatch
  | .return() -> fn A a ->
    comatch
    | .run() -> fn ka _ -> ! ka a
    end
  | .bind() -> fn A A' m f ->
    comatch
    | .run() -> fn ka ke ->
      ! m .run() { fn a -> ! f a .run() ka ke } ke
    end
  end
end

def fn mexn-err : MonadErr MExnOS =
  comatch
  | .fail() -> fn A e ->
    comatch
    | .run() -> fn _ ke -> ! ke e
    end
  end
end

def fn mexn-print : MonadPrint MExnOS =
  comatch
  | .print() -> fn s ->
    comatch
    | .run() -> fn ka _ ->
      ! write_line s { ! ka Unit() }
    end
  end
end

def fn mexn-alt : MonadAlt MExnOS =
  comatch
  | .alt() -> fn A m1 m2 ->
    comatch
    | .run() -> fn ka ke ->
      ! m1 .run() ka { fn _ ->
        ! m2 .run() ka ke
      }
    end
  end
end

def fn mexn-reduce : MonadReduce MExnOS =
  comatch
  | .reduce() -> fn A ms m ->
    do m~ <- ! foldl @(U (MExnOS A)) @(U (MExnOS A)) ms {
      fn m' m -> ret {
        comatch
        | .run() -> fn ka ke ->
          ! m' .run() ka { fn _ -> ! m .run() ka ke }
        end
      }
    } m;
    ! m~
  end
end

codata StateT (S: VType) (M: VType -> CType) (A: VType) where
  | .run(): S -> M (Pair S A)
end

def fn state_t_monad (S: VType) (M: VType -> CType) (mo: U (Monad M)) : Monad (StateT S M) =
  comatch
  | .return() -> fn A a ->
    // goal: StateT S M A
    comatch
    | .run() -> fn s -> ! mo .return() @(Pair S A) Cons(s, a)
    end
  | .bind() -> fn A A' m f -> // m: U (StateT S M A), f: U (A -> StateT S M A')
    // goal: StateT S M A'
    comatch
    | .run() -> fn s ->
      ! mo .bind() @(Pair S A) @(Pair S A') { ! m .run() s } { fn sa ->
        match sa
        | Cons(s, a) -> ! f a .run() s
        end
      }
    end
  end
end

module Print where
  def fn print-value (v: Value) (kont: U OS) : OS =
    match v
    | Bool(b) -> ! if @(OS) b { ! write_str "true" kont } { ! write_str "false" kont }
    | Thunk(c) -> ! write_str "<thunk>" kont
    end
  end
  def fn print-trace (trace: Trace) (kont: U OS) : OS =
    let kont = { ! write_line "]" kont } in
    do kont <- ! foldl @(TraceItem) @(U OS) trace { fn t kont ->
      match t
      | App(sc) -> ret {
        ! write_str "  app" {
        ! write_line "," {
        ! kont
      } } }
      | Bind(x, sc) -> ret {
        ! write_str "  bind " {
        ! write_str x {
        ! write_line "," kont
      } } }
      end
    } kont;
    let kont = { ! write_line "[" kont } in
    ! kont
  end
end

data EnvT where
  | Empty()
  | Extend(String, Value, EnvT)
end

codata EnvO where
  | .lookup(): String -> Ret (Option Value)
  | .extend(): String -> Value -> EnvO
  | .print(): U OS -> OS
end

def rec fn envo (env: EnvT) : EnvO =
  comatch
  | .lookup() -> fn x ->
    match env
    | Empty() -> ret None()
    | Extend(x', v, env') ->
      do is-eq? <- ! str_eq x x';
      match is-eq?
      | True() -> ret Some(v)
      | False() -> ! envo env' .lookup() x
      end
    end
  | .extend() -> fn x v ->
    ! envo Extend(x, v, env)
  | .print() -> fn k ->
    ! write_line "[" {
      (rec (p : Thunk (EnvT -> OS)) -> fn env -> match env
      | Empty() -> ! write_line "]" k
      | Extend(x, v, env') ->
        ! write_str "  " {
        ! write_str x {
        ! write_str " = " {
        ! print-value v {
        ! write_line "," {
          ! p env'
        } } } } }
      end) env
    }
  end
end

data Value where
  | Bool(Bool)
  | Thunk(U Compu)
end

codata Compu where
  | .app(): Value -> Compu
  | .bind(): MExnOS Value
end

def rec fn malg : Algebra MExnOS Compu =
  comatch
  | .bindA() -> fn A m f -> // m : U (MExnOS A), f: U (A -> Compu)
    comatch
    | .app() -> fn a -> // goal: Compu
      ! malg .bindA() @(A) m { fn v -> ! f v .app() a }
    | .bind() -> // goal: MExnOS Value, use ordinary bind
      ! mexn .bind() @(A) @(Value) m { fn x -> ! f x .bind() }
    end
  end
end

def rec fn malg-err : AlgebraErr MExnOS Compu =
  comatch
  | .failA() -> fn e ->
    rec unwind -> comatch
    | .app() -> fn _ -> ! unwind
    | .bind() -> ! mexn-err .fail() @(Value) e
    end
  end
end

data SValue where
  | Var(String)
  | Bool(Bool)
  | Thunk(SCompu)
end

data SCompu where
  | Lam(String, SCompu)
  | App(SCompu, SValue)
  | Ret(SValue)
  | Bind(SCompu, String, SCompu)
  | Force(SValue)
  | If(SValue, SCompu, SCompu)
  | Env(SCompu)
end

/* Parser */

codata Parser (A: VType) where
  | .run(): String -> Int -> MExnOS (Pair A Int)
end

pub def fn mp : Monad Parser =
  comatch
  | .return() -> fn A a ->
    comatch
    | .run() -> fn s i -> ! mexn .return() @(Pair A Int) Cons(a, i)
    end
  | .bind() -> fn A A' ma f ->
    comatch
    | .run() -> fn s i ->
      comatch
      | .run() -> fn ka ke ->
        ! ma .run() s i .run() { fn p -> match p | Cons(a, i) ->
          ! f a .run() s i .run() ka ke
        end } ke
      end
    end
  end
end

pub def fn mp-err : MonadErr Parser =
  comatch
  | .fail() -> fn A e ->
    comatch
    | .run() -> fn s i ->
      comatch
      | .run() -> fn _ ke -> ! ke e
      end
    end
  end
end

pub def fn mp-alt : MonadAlt Parser =
  comatch
  | .alt() -> fn A m1 m2 ->
    comatch
    | .run() -> fn s i ->
      ! mexn-alt .alt() @(Pair A Int) { ! m1 .run() s i } { ! m2 .run() s i }
    end
  end
end

pub def fn mp-cnt (A: VType) (cnt: Int) (m: U (Parser A)) : Parser A =
  comatch | .run() -> fn s i ->
    do len <- ! str_length s;
    do i' <- ! add i cnt;
    ! if~ @(MExnOS (Pair A Int)) { ! int_le i' len } {
      ! m .run() s i
    } {
      ! mexn-err .fail() @(Pair A Int) ParseError(i, "unexpected eof")
    }
  end
end

pub def fn p_char (c: Char) : Parser Char =
  ! mp-cnt @(Char) 1 {
    comatch | .run() -> fn s i ->
      ! if~ @(MExnOS (Pair Char Int)) {
        do c' <- ! str_index s i;
        ! char_eq c' c
      } {
        do i' <- ! add i 1;
        ! mexn .return() @(Pair Char Int) Cons(c, i')
      } {
        do msg <- ! char_to_str c;
        do msg <- ! str_append "missing `" msg;
        do msg <- ! str_append msg "`";
        ! mexn-err .fail() @(Pair Char Int) ParseError(i, msg)
      }
    end
  }
end

pub def fn p_word (w: String) : Parser String =
  do len <- ! str_length w;
  ! mp-cnt @(String) len {
    comatch | .run() -> fn s i ->
      let rec fn word_match (j: Int) =
        ! if~ @(Ret Bool) { ! int_eq j len } {
          ret True()
        } {
          do l <- ! add i j;
          do c1 <- ! str_index s l;
          do c2 <- ! str_index w j;
          ! if~ @(Ret Bool) { ! char_eq c1 c2 } {
            do j' <- ! add j 1;
            ! word_match j'
          } {
            ret False()
          }
        }
      in
      ! if~ @(MExnOS (Pair String Int)) { ! word_match 0 } {
        do i' <- ! add i len;
        ! mexn .return() @(Pair String Int) Cons(w, i')
      } {
        do msg <- ! str_append "word `" w;
        do msg <- ! str_append msg "` mismatch";
        ! mexn-err .fail() @(Pair String Int) ParseError(i, msg)
      }
    end
  }
end

pub def fn p_var : Parser String =
  let fn p_vc (c: Char) : Ret (Option Char) =
    do ascii <- ! char_to_int c;
    let digit = { ! and~ { ! int_lt 47 ascii } { ! int_lt ascii 58 } } in
    let cap = { ! and~ { ! int_lt 64 ascii } { ! int_lt ascii 91 } } in
    let sml = { ! and~ { ! int_lt 96 ascii } { ! int_lt ascii 123 } } in
    ! if~ @(Ret (Option Char))
      { ! or~ digit { ! or~ cap sml } }
      { ret Some(c) }
      { ret None() }
  in
  comatch | .run() -> fn s i ->
    let rec fn var (v: String) (i: Int) =
      do c <- ! str_index s i;
      do c? <- ! p_vc c;
      do i' <- ! add i 1;
      match c?
      | None() ->
        ! if~ @(MExnOS (Pair String Int)) {
          do len <- ! str_length v;
          ! int_eq len 0
        } {
          ! mexn-err .fail() @(Pair String Int) ParseError(i, "variable of length 0")
        } {
          ! mexn .return() @(Pair String Int) Cons(v, i)
        }
      | Some(c) ->
        do c <- ! char_to_str c;
        do v <- ! str_append v c;
        ! var v i'
      end
    in
    // let m = { ! var "" i } in
    // ! mexn .bind() @(Pair String Int) @(Pair String Int) m { fn vi ->
    //   ! mexn .bind() @(Unit) @(Pair String Int) {
    //     do v <- match vi | Cons(v, i) -> ret v end;
    //     do i <- match vi | Cons(v, i) -> ! int_to_str i end;
    //     do msg <- ! str_append "var[" i;
    //     do msg <- ! str_append msg "](";
    //     do msg <- ! str_append msg v;
    //     do msg <- ! str_append msg ")";
    //     ! mexn-print .print() msg
    //   } { fn _ ->
    //     ! mexn .return() @(Pair String Int) vi
    //   }
    // }
    ! var "" i
  end
end

codata ParserCbpv where
  | .value(): Parser SValue
  | .compu(): Parser SCompu
end

pub def rec fn p_cbpv : ParserCbpv =
  comatch
  | .value() ->
    let fn true =
      ! mp .bind() @(String) @(SValue) { ! p_word "true" } { fn _ ->
        ! mp .return() @(SValue) Bool(True())
      }
    in
    let fn false =
      ! mp .bind() @(String) @(SValue) { ! p_word "false" } { fn _ ->
        ! mp .return() @(SValue) Bool(False())
      }
    in
    let fn var =
      ! mp .bind() @(String) @(SValue) p_var { fn v ->
        ! mp .return() @(SValue) Var(v)
      }
    in
    let fn thunk =
      ! mp .bind() @(Char) @(SValue) { ! p_char '{' } { fn _ ->
      ! mp .bind() @(SCompu) @(SValue) { ! p_cbpv .compu() } { fn sc ->
      ! mp .bind() @(Char) @(SValue) { ! p_char '}' } { fn _ ->
        ! mp .return() @(SValue) Thunk(sc)
      } } }
    in
    ! mp-alt .alt() @(SValue) true {
    ! mp-alt .alt() @(SValue) false {
    ! mp-alt .alt() @(SValue) var thunk
    } }
  | .compu() ->
    let fn _env =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) { ! p_word "env" } { fn _ ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) Env(sc)
      } } } } }
    in
    let fn _ret =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) { ! p_word "ret" } { fn _ ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() } { fn sv ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) Ret(sv)
      } } } } }
    in
    let fn _bind =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) { ! p_word "bind" } { fn _ ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc1 ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) p_var { fn v ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc2 ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) Bind(sc1, v, sc2)
      } } } } } } } } }
    in
    let fn _force =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) { ! p_word "call" } { fn _ ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() } { fn sv ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) Force(sv)
      } } } } }
    in
    let fn _if =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) { ! p_word "if" } { fn _ ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() } { fn sv ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc1 ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc2 ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) If(sv, sc1, sc2)
      } } } } } } } } }
    in
    let fn _lam =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) { ! p_word "fn" } { fn _ ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(String) @(SCompu) p_var { fn v ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) Lam(v, sc)
      } } } } } } }
    in
    let fn _app =
      ! mp .bind() @(Char) @(SCompu) { ! p_char '(' } { fn _ ->
      // ! mp .bind() @(String) @(SCompu) { ! p_word "app" } { fn _ ->
      // ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SCompu) @(SCompu) { ! p_cbpv .compu() } { fn sc ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ' ' } { fn _ ->
      ! mp .bind() @(SValue) @(SCompu) { ! p_cbpv .value() } { fn sv ->
      ! mp .bind() @(Char) @(SCompu) { ! p_char ')' } { fn _ ->
        ! mp .return() @(SCompu) App(sc, sv)
      } } } } }
      // } }
    in
    ! mp-alt .alt() @(SCompu) _env {
    ! mp-alt .alt() @(SCompu) _ret {
    ! mp-alt .alt() @(SCompu) _bind {
    ! mp-alt .alt() @(SCompu) _force {
    ! mp-alt .alt() @(SCompu) _if {
    ! mp-alt .alt() @(SCompu) _lam _app
    } } } } }
  end
end

pub def fn p_main (s: String) : MExnOS SCompu =
  ! mexn .bind() @(Pair SCompu Int) @(SCompu) { ! p_cbpv .compu() .run() s 0 } { fn sci ->
    match sci
    | Cons(sc, i) ->
      ! if~ @(MExnOS SCompu) {
        do len <- ! str_length s;
        ! int_eq i len
      } {
        ! mexn .return() @(SCompu) sc
      } {
        ! mexn-err .fail() @(SCompu) ParseError(i, "not eof after parsing")
      }
    end
  }
end

/* Interpretor */

data TraceItem where
  | App(SCompu)
  | Bind(String, SCompu)
end

alias Trace = List TraceItem end

codata Interp where
  | .value(): SValue -> MExnOS Value
  | .compu(): SCompu -> Compu
end

def rec fn interp (env: U EnvO) (trace: Trace) : Interp =
  comatch
  | .value() -> fn sv ->
    match sv
    | Var(x) ->
      do x? <- ! env .lookup() x;
      match x?
      | None() -> ! mexn-err .fail() @(Value) FreeVariable()
      | Some(v) ->
        ! mexn .return() @(Value) v
      end
    | Bool(b) ->
      ! mexn .return() @(Value) Bool(b)
    | Thunk(c) ->
      ! mexn .return() @(Value) Thunk({ ! interp env trace .compu() c })
    end
  | .compu() -> fn sc ->
    match sc
    | Lam(x, sc) ->
      comatch
      | .app() -> fn v ->
        ! interp { ! env .extend() x v } trace .compu() sc
      | .bind() -> ! mexn-err .fail() @(Value) TypeError()
      end
    | App(sc, sv) ->
      let trace': Trace = Cons(App(sc), trace) in
      let mv = { ! interp env trace' .value() sv } in
      ! malg .bindA() @(Value) mv { fn v -> ! interp env trace .compu() sc .app() v }
    | Ret(sv) ->
      comatch
      | .app() -> fn _ -> ! malg-err .failA() TypeError()
      | .bind() -> ! interp env trace .value() sv
      end
    | Bind(sc1, x, sc2) ->
      let trace': Trace = Cons(Bind(x, sc2), trace) in
      let mv = { ! interp env trace' .compu() sc1 .bind() } in
      ! malg .bindA() @(Value) mv { fn v ->
        ! interp { ! env .extend() x v } trace .compu() sc2
      }
    | Force(sv) ->
      let mv = { ! interp env trace .value() sv } in
      ! malg .bindA() @(Value) mv { fn v ->
        match v
        | Bool(_) -> ! malg-err .failA() TypeError()
        | Thunk(c) -> ! c
        end
      }
    | If(sv, c1, c2) ->
      let mv = { ! interp env trace .value() sv } in
      ! malg .bindA() @(Value) mv { fn v ->
        match v
        | Bool(b) ->
          match b
          | True() -> ! interp env trace .compu() c1
          | False() -> ! interp env trace .compu() c2
          end
        | Thunk(_) -> ! malg-err .failA() TypeError()
        end
      }
    | Env(sc) ->
      let mp: U (MExnOS Unit) = {
        comatch
        | .run() -> fn ka _ ->
          ! write_line "[[DEBUG]]" {
          ! write_str "[env]: " {
          ! env .print() {
          ! write_str "[trace]: " {
          ! print-trace trace {
          ! write_line "" {
          ! read_line { fn _ ->
          ! ka Unit()
          } } } } } } }
        end
      } in
      ! malg .bindA() @(Unit) mp { fn _ ->
        ! interp env trace .compu() sc
      }
    end
  end
end


def fn value-eq (v1: Value) (v2: Value) (k: U OS) : OS =
  let bool-value-panic = { ! panic "wrong bool value" } in
  let thunk-panic = { ! panic "thunks are not comparable" } in
  match v1
  | Bool(b1) ->
    match v2
    | Bool(b2) ->
      do eq? <- ! bool_eq b1 b2;
      match eq?
      | True() -> ! write_line "\\^o^/" k
      | False() -> ! bool-value-panic
      end
    | Thunk(_) -> ! thunk-panic
    end
  | Thunk(_) -> ! thunk-panic
  end
end

def fn report (e: Exception) : OS =
  match e
  | ParseError(loc, msg) ->
    do loc <- ! int_to_str loc;
    do loc <- ! str_append loc ": ";
    do msg <- ! str_append loc msg;
    ! panic msg
  | FreeVariable() -> ! panic "free variable"
  | TypeError() -> ! panic "type error"
  end
end

main
  let env : U EnvO = { ! envo Empty() } in
  let fn demo (src: String) (ans: Value) (k: U OS): OS =
    ! mexn .bind() @(SCompu) @(Value) { ! p_main src } { fn term ->
      ! interp env Nil() .compu() term .bind()
    } .run() { fn v ->
      ! value-eq v ans k
    } report
  in
  // if true then ret true else ret false
  let src1 = "(if true (ret true) (ret false))" in
  let ans1: Value = Bool(True()) in
  // (do x <- ret True in \b -> if b then ret x else ret False) True
  let src2 = "(bind (ret true) x ((fn b (if b (ret x) (ret false))) true))" in
  let ans2: Value = Bool(True()) in
  ! demo src1 ans1 {
  ! demo src2 ans2 {
  ! exit 0 }}
end
